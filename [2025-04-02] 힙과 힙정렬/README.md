# π“ ν™ Heap

> π’΅ **μ™„μ „ μ΄μ§„ νΈλ¦¬(Complete Binary Tree)**μ μΌμΆ…μΌλ΅, λ¨λ“  λ…Έλ“μ κ°’μ΄ νΉμ • κ·μΉ™μ„ λ§μ΅±ν•λ” μλ£κµ¬μ΅°

> β“ μ™„μ „ μ΄μ§„ νΈλ¦¬  
> ![μ™„μ „ μ΄μ§„ νΈλ¦¬](../img/heap/completebinarytree.png)<br>μ΄μ§„ νΈλ¦¬ κµ¬μ΅°μ—μ„ λ¨λ“  λ λ²¨μ΄ κ½‰ μ°¨ μκ±°λ‚, λ§μ§€λ§‰ λ λ²¨μ„ μ μ™Έν• λ¨λ“  λ…Έλ“κ°€ μ±„μ›μ Έμλ” μ΄μ§„νΈλ¦¬μ΄λ‹¤.<br>λ§μ§€λ§‰ λ λ²¨μ λ…Έλ“λ“¤μ€ μ™Όμ½λ¶€ν„° μμ„λ€λ΅ μ°¨μλ‹¤.<br>μ¶μ² : https://chamdom.blog/binary-tree/

<br>

## μΆ…λ¥

### μµμ† ν™ Min Heap

> π’΅ λ¶€λ¨ λ…Έλ“μ κ°’μ΄ μμ‹ λ…Έλ“μ κ°’λ³΄λ‹¤ μ‘κ±°λ‚ κ°™μ€ μ™„μ „ μ΄μ§„ νΈλ¦¬

```jsx
          1
        /   \
       3     6
      / \   / \
     5   9 8   7
```

- λ£¨νΈ λ…Έλ“κ°€ κ°€μ¥ μ‘μ€ κ°’μ„ κ°€μ§„λ‹¤
- μ°μ„ μμ„ ν(Priority Queue) κµ¬ν„μ— λ§μ΄ μ‚¬μ©λλ‹¤

<br>

### μµλ€ ν™ Max Heap

> π’΅ λ¶€λ¨ λ…Έλ“μ κ°’μ΄ μμ‹ λ…Έλ“μ κ°’λ³΄λ‹¤ ν¬κ±°λ‚ κ°™μ€ μ™„μ „ μ΄μ§„ νΈλ¦¬

```jsx
          9
        /   \
       7     8
      / \   / \
     5   3 6   1
```

- λ£¨νΈ λ…Έλ“κ°€ κ°€μ¥ ν° κ°’μ„ κ°€μ§„λ‹¤
- ν™ μ •λ ¬(Heap Sort)μ— μ‚¬μ©λλ©°, μµλ“κ°’ λλ” μµμ†κ°’μ„ λΉ λ¥΄κ² μ¶”μ¶ν•λ”λ° μ μ©ν•λ‹¤

<br>

### νΉμ§•

- μ™„μ „ μ΄μ§„ νΈλ¦¬λ΅ κµ¬ν„λλ‹¤
- μ‚½μ…, μ‚­μ  μ—°μ‚°μ μ‹κ°„ λ³µμ΅λ„λ” O(log n)μ΄λ‹¤
- λ°°μ—΄μ„ μ‚¬μ©ν•μ—¬ ν¨μ¨μ μΌλ΅ κµ¬ν„μ΄ κ°€λ¥ν•λ‹¤

<br>

# π“Β ν™ μ •λ ¬ Heap Sort

> π’΅ ν™ μλ£κµ¬μ΅°λ¥Ό κΈ°λ°μΌλ΅ ν• μ •λ ¬ μ•κ³ λ¦¬μ¦
> μΌλ°μ μΌλ΅ μµλ€ ν™ Max Heapμ„ μ΄μ©ν•μ—¬ μ¤λ¦„μ°¨μ μ •λ ¬μ„ μν–‰

## λ™μ‘ κ³Όμ •

1. μ£Όμ–΄μ§„ λ°°μ—΄μ„ μµλ€ ν™μΌλ΅ λ³€ν™ (Heapify κ³Όμ •)
2. λ£¨νΈ λ…Έλ“(κ°€μ¥ ν° κ°’)μ™€ λ°°μ—΄μ λ§μ§€λ§‰ μ”μ†λ¥Ό κµν™
3. ν™μ ν¬κΈ°λ¥Ό μ¤„μ΄κ³ , λ‹¤μ‹ μµλ€ ν™μ νΉμ„±μ„ μ μ§€ν•λ„λ΅ μ΅°μ •
4. μ„ κ³Όμ •μ„ λ¨λ“  μ”μ†μ— λ€ν•΄ λ°λ³µν•μ—¬ μ •λ ¬

<br>

## μ¥μ 

- μ‹κ°„ λ³µμ΅λ„κ°€ μ•μ •μ μΌλ΅ O($n log n$)μ„ μ μ§€
- μ¶”κ°€ λ©”λ¨λ¦¬κ°€ κ±°μ ν•„μ”ν•μ§€ μ•μ

<br>

## λ‹¨μ 

- κµ¬ν„μ΄ λ³µμ΅
- μ•μ • μ •λ ¬(Stable Sort)μ΄ μ•„λ‹

<br>

## μ‹κ°„/κ³µκ°„ λ³µμ΅λ„

- μ‹κ°„ λ³µμ΅λ„: O($n log n$) β†’ μµμ„ , ν‰κ· , μµμ•… λ¨λ‘ λ™μΌ
- κ³µκ°„ λ³µμ΅λ„: O(1) β†’ μ¶”κ°€ λ©”λ¨λ¦¬ μ‚¬μ© μ—†μ

<br>

## μ½”λ“

```jsx
function heapify(arr, size, root) {
  let largest = root;
  const left = 2 * root + 1;
  const right = 2 * root + 2;

  if (left < size && arr[left] > arr[largest]) largest = left;
  if (right < size && arr[right] > arr[largest]) largest = right;

  if (largest !== root) {
    [arr[root], arr[largest]] = [arr[largest], arr[root]];
    heapify(arr, size, largest); // μ¬κ·€μ μΌλ΅ λ³€κ²½λ λ…Έλ“μ— λ€ν•΄ heapify μν–‰
  }
}

function buildMaxHeap(arr) {
  const len = arr.length;

  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(arr, len, i);
  }
}
function heapSort(arr) {
  const len = arr.length;

  // μµλ€ ν™ λ³€ν™
  buildMaxHeap(arr);

  // ν•λ‚μ”© μ¶”μ¶ν•μ—¬ μ •λ ¬
  for (let i = len - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    heapify(arr, i, 0);
  }
  return arr;
}

console.log(heapSort([5, 3, 8, 4, 2])); // [2, 3, 4, 5, 8]
```
